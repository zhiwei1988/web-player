# WebSocket 媒体流自定义帧协议设计

## 一、设计背景

本协议用于网络摄像机 Web 端与设备端之间，基于 WebSocket 传输媒体流数据的场景。替代原有的 RTP 协议，实现更轻量、更适配 WebSocket/TCP 传输特性的帧封装方案。

### 设计目标

- **轻量高效**：最小化帧头开销，适配嵌入式设备资源约束
- **多类型承载**：支持视频、音频、图片、智能元数据、控制消息等多种数据类型
- **前向兼容**：通过版本号、扩展头长度、位图等机制，确保新旧版本设备和 Web 端可以兼容工作
- **弱网友好**：通过应用层分片和交织发送策略，降低大帧对音频和实时性数据的阻塞

---

## 二、协议帧结构总览

协议采用 **固定帧头 + 可选扩展头 + 负载数据** 的三段式结构。

扩展头区域内部按固定顺序最多包含三层：**分片扩展头 → 通用扩展头 → 类型专用扩展头**，每层是否存在由固定帧头中的标志位决定。

```
+--------------------+---------------------------------------------------+------------+
|   固定帧头 (13B)    |          扩展头 (ext_length 字节)                   |  Payload   |
|   所有消息必须携带   |  [分片扩展头] + [通用扩展头] + [类型专用扩展头]       |  实际数据   |
+--------------------+---------------------------------------------------+------------+
```

---

## 三、固定帧头（13 字节）

| 字段           | 偏移 | 大小   | 说明                                                             |
| -------------- | ---- | ------ | ---------------------------------------------------------------- |
| magic          | 0    | 2 字节 | 固定魔数 `0xEB01`，用于帧同步和校验                              |
| version        | 2    | 1 字节 | 协议版本号，当前为 `1`                                           |
| msg_type       | 3    | 1 字节 | 消息类型，详见消息类型定义                                       |
| flags          | 4    | 1 字节 | 标志位，按 bit 定义                                              |
| timestamp      | 5    | 8 字节 | 相对时间戳，单位毫秒，用于音视频同步                             |
| ext_length     | 13   | 1 字节 | 扩展头总长度（含分片扩展头 + 通用扩展头 + 类型专用扩展头），最大 255 字节 |
| payload_length | 14   | 4 字节 | 负载数据长度 |
| reserved       | 18   | 2 字节 | 保留字段 |

### 3.1 msg_type 消息类型定义

| 值        | 类型     | 说明                                     |
| --------- | -------- | ---------------------------------------- |
| 0x01      | VIDEO    | 视频帧数据                               |
| 0x02      | AUDIO    | 音频帧数据                               |
| 0x03      | IMAGE    | 图片数据（抓图、缩略图等）               |
| 0x04      | METADATA | 智能分析元数据（目标检测框、人脸特征等） |
| 0x05      | CONTROL  | 控制消息（心跳、流控、错误通知等）       |
| 0x10-0xFF | 保留     | 未来扩展                                 |

### 3.2 flags 标志位定义

| Bit | 名称       | 说明                                             |
| --- | ---------- | ------------------------------------------------ |
| 0   | FRAGMENT   | 1 = 包含分片扩展头                               |
| 1   | ENCRYPTED  | 1 = 负载数据已加密                               |
| 2   | COMPRESSED | 1 = 负载数据已压缩（主要用于 METADATA 等文本型数据） |
| 3   | HAS_COMMON | 1 = 包含通用扩展头                               |
| 4-7 | 保留       | 置 0                                             |

---

## 四、扩展头

扩展头区域由三层组成，按固定顺序排列。每层是否存在由 `flags` 标志位决定，各层有独立的边界确定机制，可以独立演进、互不影响。

```
扩展头 = [分片扩展头(可选, 固定6B)] + [通用扩展头(可选, 自描述长度)] + [类型专用扩展头(可变)]
```

### 4.1 第一层：分片扩展头（6 字节，固定长度）

当 `flags.FRAGMENT = 1` 时存在，始终位于扩展头区域起始位置。详见第五章分片机制。

| 字段            | 大小   | 说明                                               |
| --------------- | ------ | -------------------------------------------------- |
| frame_id        | 2 字节 | 原始帧 ID，同一帧的所有分片共享相同 ID，递增溢出回绕 |
| fragment_index  | 2 字节 | 当前分片序号，从 0 开始                            |
| total_fragments | 2 字节 | 该帧的总分片数                                     |

**边界确定**：由 `flags.FRAGMENT` 标识存在性，长度固定 6 字节。

### 4.2 第二层：通用扩展头（可变长度，自描述）

当 `flags.HAS_COMMON = 1` 时存在。用于承载所有消息类型共用的通用信息（如绝对时间戳、数字水印等），避免在每种类型专用扩展头中重复定义。

| 字段          | 大小   | 说明                                                 |
| ------------- | ------ | ---------------------------------------------------- |
| common_length | 1 字节 | 通用扩展头总长度（含本字节），用于前向兼容跳过       |
| common_flags  | 1 字节 | 位图，标识后续携带了哪些通用字段                     |
| 字段数据...   | 可变   | 按 common_flags 位图中置 1 的位，顺序排列对应字段    |

**common_flags 位图定义**：

| Bit | 字段       | 大小   | 说明                               |
| --- | ---------- | ------ | ---------------------------------- |
| 0   | abs_time   | 8 字节 | 绝对时间戳，UTC 毫秒              |
| 1   | watermark  | 4 字节 | 数字水印标识                       |
| 2   | seq_number | 4 字节 | 全局递增序列号，用于端到端丢帧统计 |
| 3-7 | 保留       | -      | 未来扩展                           |

每个 bit 对应的字段大小由协议预定义。接收端根据位图即可精确计算各字段偏移。`common_length` 的作用是：当新版本增加了新的 bit 定义，旧接收端不认识新 bit，仍能通过 `common_length` 跳过整个通用扩展头。

**示例**：携带绝对时间戳 + 数字水印：

```
common_length = 14  (1 + 1 + 8 + 4)
common_flags  = 0x03 (bit0 和 bit1 置 1)
abs_time      = [8 字节 UTC 毫秒]
watermark     = [4 字节水印数据]
```

**边界确定**：由 `flags.HAS_COMMON` 标识存在性，由 `common_length` 自描述长度。

### 4.3 第三层：类型专用扩展头（可变长度）

根据 `msg_type` 不同携带对应的专用字段，仅出现在非分片消息或分片首片（`fragment_index = 0`）中。

类型专用扩展头的长度 = `ext_length` - 分片扩展头长度(如有) - 通用扩展头长度(如有)。

**边界确定**：由 `ext_length` 减去前两层长度得出。接收端根据自身版本认知的字段长度解析已知部分，忽略尾部多余字节（前向兼容）。

#### 4.3.1 视频扩展头（4 字节）

| 字段       | 大小   | 说明                                                                 |
| ---------- | ------ | -------------------------------------------------------------------- |
| codec      | 1 字节 | 编码类型：1=H.264, 2=H.265, 3=MJPEG                                 |
| frame_type | 1 字节 | 帧类型：1=IDR, 2=I, 3=P, 4=B, 5=SPS/PPS, 6=VPS                     |
| resolution | 2 字节 | 高 4 位保留 + 12 位编码，映射到预定义分辨率表；0 表示在 SPS 中自描述 |

#### 4.3.2 音频扩展头（3 字节）

| 字段        | 大小   | 说明                                                 |
| ----------- | ------ | ---------------------------------------------------- |
| codec       | 1 字节 | 编码类型：1=G.711A, 2=G.711U, 3=AAC, 4=G.726, 5=PCM |
| sample_rate | 1 字节 | 采样率索引：1=8000, 2=16000, 3=44100, 4=48000        |
| channels    | 1 字节 | 声道数                                               |

#### 4.3.3 图片扩展头（4 字节）

| 字段    | 大小   | 说明                                   |
| ------- | ------ | -------------------------------------- |
| format  | 1 字节 | 图片格式：1=JPEG, 2=PNG, 3=BMP        |
| purpose | 1 字节 | 用途：1=手动抓图, 2=报警抓图, 3=缩略图 |
| pic_id  | 2 字节 | 图片 ID，用于与智能元数据关联          |

#### 4.3.4 元数据扩展头（4 字节）

| 字段         | 大小   | 说明                                              |
| ------------ | ------ | ------------------------------------------------- |
| meta_type    | 1 字节 | 子类型：1=目标检测, 2=人脸识别, 3=行为分析, 4=OSD |
| format       | 1 字节 | 数据格式：1=JSON, 2=自定义二进制, 3=Protobuf      |
| assoc_stream | 1 字节 | 关联的 stream_id，标明该元数据属于哪路视频流       |
| reserved     | 1 字节 | 保留，置 0                                        |

#### 4.3.5 控制消息扩展头（2 字节）

| 字段      | 大小   | 说明                                                               |
| --------- | ------ | ------------------------------------------------------------------ |
| ctrl_type | 1 字节 | 控制类型：1=心跳, 2=心跳响应, 3=流控, 4=错误通知, 5=流参数变更通知 |
| reserved  | 1 字节 | 保留，置 0                                                         |

---

## 五、应用层分片机制

### 5.1 分片的必要性

WebSocket 基于 TCP，不存在 IP 层分片问题，但存在**应用层队头阻塞**问题：

- 大 I 帧（数十到数百 KB）作为单条 WebSocket 消息发送时，浏览器端须等整条消息接收完毕才能交付应用层
- 弱网下 TCP 丢包重传会放大这个延迟
- 大消息传输期间，其后的音频帧、元数据等实时性要求更高的数据被阻塞

应用层分片的核心价值：**将大帧拆成小片，与高优先级消息交织发送，实现消息级的优先级调度**。

### 5.2 分片规则

**分片阈值**：单个分片负载建议控制在 **16KB**。

阈值依据：

- 足够小，可有效实现与音频帧等小消息的交织发送
- 足够大，帧头开销可忽略不计（约 0.14%）
- 与 TCP 拥塞窗口初始值（约 10 × MSS ≈ 14.6KB）较匹配

**发送端分片流程**：

1. 编码器输出完整帧
2. 帧大小 ≤ 分片阈值 → `flags.FRAGMENT = 0`，正常发送单条消息
3. 帧大小 > 分片阈值 → 按阈值拆分，生成 N 个分片消息：
   - **首片（fragment_index = 0）**：固定帧头 + 分片扩展头 + 通用扩展头(如有) + 类型专用扩展头 + 负载
   - **后续分片（fragment_index > 0）**：固定帧头 + 分片扩展头 + 负载（不携带通用扩展头和类型专用扩展头）

### 5.3 接收端重组流程

1. 读取 13 字节固定帧头
2. 根据 `ext_length` 读取扩展头，根据 `payload_length` 读取负载
3. 检查 `flags.FRAGMENT`：
   - 为 0 → 完整帧，直接交付上层
   - 为 1 → 以 `(stream_id, msg_type, frame_id)` 为 key 缓存分片
4. 收齐所有分片（`fragment_index` 从 0 到 `total_fragments - 1`）后，按序拼接负载，连同首片的通用扩展头和类型专用扩展头一起交付上层
5. **超时保护**：若某帧分片在 500ms 内未收齐，丢弃该帧（视频丢帧优于长时间卡顿等待）

### 5.4 交织发送策略

分片配合发送端调度使用，摄像机端维护带优先级的发送队列。

**优先级（从高到低）**：

| 优先级    | 消息类型                 |
| --------- | ------------------------ |
| 1（最高） | 控制消息（心跳、流控等） |
| 2         | 音频帧                   |
| 3         | 智能元数据               |
| 4         | 视频 IDR/I 帧分片        |
| 5         | 视频 P/B 帧分片          |
| 6（最低） | 图片分片                 |

**调度规则**：每发送一个低优先级分片后，检查是否有更高优先级消息等待发送，有则优先发出后再继续。

**示例**：一个 50KB 的 I 帧与一个 320B 的音频帧几乎同时产生：

```
[Video 分片0 16KB] → [Audio 完整帧 320B] → [Video 分片1 16KB] → [Video 分片2 16KB] → [Video 分片3 2KB]
```

音频帧在视频第一个分片之后即被发出，不必等待整个视频帧传输完毕。

---

## 六、扩展头解析流程

接收端对扩展头区域的三层结构按以下流程解析，每层有独立的边界确定机制：

```
offset = 0

// 第一层：分片扩展头（固定 6 字节）
if flags.FRAGMENT == 1:
    解析 ext_data[offset .. offset+6] 为分片扩展头
    offset += 6

// 第二层：通用扩展头（common_length 自描述）
if flags.HAS_COMMON == 1:
    common_length = ext_data[offset]
    解析 ext_data[offset .. offset+common_length] 中已知字段，忽略未知位
    offset += common_length

// 第三层：类型专用扩展头（剩余部分）
type_ext_length = ext_length - offset
if type_ext_length > 0:
    根据 msg_type 解析已知字段，忽略尾部多余字节

// 最后读取 payload_length 字节的负载数据
```

### 扩展头有效性校验

| 校验项                 | 规则                                                                                 | 异常处理                                                                 |
| ---------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------ |
| 分片扩展头存在性       | `FRAGMENT=1` 时，`ext_length` 必须 ≥ 6                                              | 小于 6 则丢弃该帧                                                        |
| 通用扩展头存在性       | `HAS_COMMON=1` 时，剩余 `ext_length` 必须 ≥ 2（至少含 common_length + common_flags） | 不足则丢弃该帧                                                           |
| 通用扩展头长度一致性   | `common_length` 值不应超过剩余 `ext_length`                                          | 不一致则丢弃该帧                                                         |
| 类型专用扩展头最小长度 | 根据 `msg_type` 查表得到当前版本已知最小长度，实际长度不应小于该值                    | 小于最小长度则丢弃                                                       |
| 后续分片的扩展头       | `FRAGMENT=1` 且 `fragment_index > 0` 时，`ext_length` 应为 6（仅含分片扩展头）       | 正常，等待重组                                                           |
| 未知 msg_type          | 不认识的类型，无法解析类型专用扩展头                                                 | 根据 `ext_length` 跳过扩展头，根据 `payload_length` 跳过负载，继续下一帧 |

---

## 七、各类型消息帧布局示例

### 7.1 非分片视频帧（无通用扩展头）

```
+---------------+------------------+-----------+
| 固定帧头 20B   | 视频扩展头 4B     | Payload   |
| FRAGMENT=0    |                  |           |
| HAS_COMMON=0  |                  |           |
| ext_length=4  |                  |           |
+---------------+------------------+-----------+
```

### 7.2 非分片视频帧（带通用扩展头，含绝对时间戳 + 水印）

```
+---------------+--------------------+------------------+-----------+
| 固定帧头 20B   | 通用扩展头 14B      | 视频扩展头 4B     | Payload   |
| FRAGMENT=0    | common_length=14   |                  |           |
| HAS_COMMON=1  | common_flags=0x03  |                  |           |
| ext_length=18 | abs_time + wmark   |                  |           |
+---------------+--------------------+------------------+-----------+
```

### 7.3 分片视频帧首片（带通用扩展头）

```
+---------------+--------------+--------------------+------------------+-----------+
| 固定帧头 20B   | 分片扩展头 6B | 通用扩展头 14B      | 视频扩展头 4B     | Payload   |
| FRAGMENT=1    |              | common_length=14   |                  |           |
| HAS_COMMON=1  |              | common_flags=0x03  |                  |           |
| ext_length=24 |              |                    |                  |           |
+---------------+--------------+--------------------+------------------+-----------+
```

### 7.4 分片视频帧后续片

```
+---------------+--------------+-----------+
| 固定帧头 20B   | 分片扩展头 6B | Payload   |
| FRAGMENT=1    |              |           |
| HAS_COMMON=0  |              |           |
| ext_length=6  |              |           |
+---------------+--------------+-----------+
```

### 7.5 音频帧（带通用扩展头，仅含绝对时间戳）

```
+---------------+--------------------+------------------+-----------+
| 固定帧头 20B   | 通用扩展头 10B      | 音频扩展头 3B     | Payload   |
| FRAGMENT=0    | common_length=10   |                  |           |
| HAS_COMMON=1  | common_flags=0x01  |                  |           |
| ext_length=13 |                    |                  |           |
+---------------+--------------------+------------------+-----------+
```

### 7.6 控制消息（心跳，无通用扩展头）

```
+---------------+--------------------+
| 固定帧头 20B   | 控制扩展头 2B       |
| FRAGMENT=0    | ctrl_type=1        |
| HAS_COMMON=0  |                    |
| ext_length=2  |                    |
+---------------+--------------------+
```

---

## 八、前向兼容性保障

协议通过多层级机制确保新旧版本兼容：

| 层级           | 机制              | 作用                                                                                       |
| -------------- | ----------------- | ------------------------------------------------------------------------------------------ |
| 固定帧头       | `version` 字段    | 接收端根据版本号选择对应的解析策略                                                         |
| 固定帧头       | `ext_length` 字段 | 即使不认识扩展头内部新增字段，也能根据总长度正确跳过，定位到负载数据                       |
| 固定帧头       | `flags` 保留位    | 旧版本忽略不认识的标志位，不影响已有逻辑                                                   |
| 固定帧头       | `msg_type` 保留值 | 收到未知类型时，根据 `ext_length` 和 `payload_length` 跳过整条消息，继续解析下一帧         |
| 通用扩展头     | `common_length`   | 旧接收端不认识新增的通用字段时，根据长度跳过整个通用扩展头                                 |
| 通用扩展头     | `common_flags`    | 新增字段通过新 bit 位定义，旧接收端忽略不认识的 bit，只解析已知字段                        |
| 类型专用扩展头 | 尾部忽略原则      | 类型专用扩展头长度由 `ext_length` 减去前两层得出，旧接收端按已知长度解析，忽略尾部新增字段 |

**典型兼容场景**：

- **新增通用字段**：V2 在通用扩展头中新增 bit3 定义的加密标识字段，V1 接收端读到 `common_flags` 中 bit3 为 1 但不认识，根据 `common_length` 跳过整个通用扩展头，其余解析不受影响
- **扩展类型专用字段**：V2 给视频扩展头新增 2 字节 ROI 字段，V1 接收端计算出类型专用扩展头长度为 6 字节，按已知的 4 字节解析，忽略尾部 2 字节，视频正常解码
- **新增消息类型**：V2 新增 `msg_type=0x06` 的告警数据类型，V1 接收端不认识该类型，根据 `ext_length` 跳过扩展头、`payload_length` 跳过负载，继续处理后续帧
