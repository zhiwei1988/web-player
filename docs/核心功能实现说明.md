# 代码核心功能概述

本文档概述了 `src/js/` 和 `src/worker/` 目录中的核心功能逻辑。

## 目录结构

- `src/js/decoder/types.ts` - 类型定义
- `src/js/decoder/DecoderWrapper.ts` - 解码器包装类
- `src/js/decoder/WorkerBridge.ts` - Worker 桥接类
- `src/worker/decode-worker.ts` - Web Worker 实现

## 核心功能模块

### 1. 类型定义 (`types.ts`)

定义了整个解码系统的公共类型：

- **CodecType**: 编解码器类型，支持 `'h264'` 和 `'hevc'`
- **DecoderConfig**: 解码器配置接口，包含编解码类型和可选的 WASM 路径
- **VideoFrame**: 视频帧数据结构，包含宽高、PTS、时长以及 YUV 数据（yData, uData, vData）和对应的 stride
- **DecodeStatus**: 解码状态枚举（成功、需要更多数据、错误、流结束）
- **DecoderStats**: 解码器统计信息（总帧数、丢帧数、平均解码时间、当前 FPS）
- **WorkerRequest/WorkerResponse**: 主线程与 Worker 之间的消息类型定义
- **EmscriptenModule**: WASM 模块接口定义，包含 ccall、内存操作等

### 2. 解码器包装类 (`DecoderWrapper.ts`)

浏览器端对 WASM 解码器的封装类，主要功能：

#### 初始化 (`init`)
- 动态加载 WASM 模块（`decoder.js` 和 `decoder.wasm`）
- 根据 `codecType` 调用 C 函数 `decoder_init_video` 初始化解码器
- 检查浏览器 BigInt 支持
- 设置初始化状态和时间戳

#### 解码 (`decode`)
- 为输入数据分配 WASM 内存
- 调用 `decoder_send_video_packet` 发送数据包（支持 PTS）
- 调用 `decoder_receive_video_frame` 接收解码后的帧
- 处理 `NEED_MORE_DATA` 状态（返回 null）
- 从 WASM 内存中提取 YUV 数据（通过 `extractVideoFrame`）
- 更新解码统计信息（解码时间、FPS 等）

#### 刷新 (`flush`)
- 调用 `decoder_flush_video` 刷新解码器缓冲区
- 循环接收所有剩余帧直到 `NEED_MORE_DATA` 或 `END_OF_STREAM`

#### 其他功能
- `destroy`: 销毁解码器并释放资源
- `getVersion/getFFmpegVersion`: 获取版本信息
- `getStats`: 获取解码统计信息
- `isInitialized`: 检查初始化状态

### 3. Worker 桥接类 (`WorkerBridge.ts`)

主线程与 Web Worker 之间的通信桥接，提供异步解码接口：

#### 初始化
- 创建 Web Worker 实例（模块类型）
- 发送 `init` 请求并等待 `ready` 响应
- 10 秒超时保护

#### 解码操作
- `decode`: 发送解码请求到 Worker，使用 Transferable 对象传输数据
- `flush`: 发送刷新请求
- `destroy`: 发送销毁请求，延迟终止 Worker

#### 回调机制
- `onFrame`: 注册帧回调
- `onStats`: 注册统计信息回调
- `onError`: 注册错误回调

#### 消息处理
- 处理 Worker 返回的 `frame`、`stats`、`error`、`destroyed`、`ready` 消息
- 错误处理和日志记录

### 4. Web Worker 实现 (`decode-worker.ts`)

在独立线程中运行解码器，避免阻塞主线程：

#### 消息处理
- **init**: 创建 `DecoderWrapper` 实例并初始化，返回 `ready` 响应，启动统计信息定时器（每秒推送一次）
- **decode**: 调用解码器解码数据，如果成功解码出帧，将 Y/U/V buffer 作为 Transferable 对象发送回主线程
- **flush**: 刷新解码器并发送所有剩余帧
- **destroy**: 清理解码器和定时器，返回 `destroyed` 响应

#### 错误处理
- 全局 `onerror` 和 `onunhandledrejection` 处理器
- 将错误包装为 `error` 消息发送回主线程

## 工作流程

1. **初始化流程**:
   ```
   主线程 → WorkerBridge.init() → Worker (init) → DecoderWrapper.init() → WASM 模块加载
   ```

2. **解码流程**:
   ```
   主线程 → WorkerBridge.decode() → Worker (decode) → DecoderWrapper.decode() → WASM 解码 → 返回 VideoFrame
   ```

3. **数据传递**:
   - 输入数据通过 `postMessage` 的 Transferable 机制传输
   - 解码后的 YUV 数据也通过 Transferable 传输，避免复制开销

## 技术特点

- **异步非阻塞**: 使用 Web Worker 在独立线程中解码，不阻塞主线程
- **内存高效**: 使用 Transferable 对象传输大型数据，避免数据复制
- **类型安全**: 完整的 TypeScript 类型定义
- **错误处理**: 完善的错误处理和超时机制
- **性能监控**: 实时统计解码性能（FPS、解码时间等）
- **WASM 集成**: 通过 Emscripten 生成的 WASM 模块进行底层解码

## 技术细节

### TypeScript 接口语法

`EmscriptenModule` 接口使用了以下 TypeScript 语法特性：

- **接口定义**: 使用 `export interface` 导出接口类型
- **函数类型**: 使用箭头函数语法 `(params) => returnType` 定义函数类型
- **联合类型**: 使用 `|` 运算符，如 `string | null`、`number | bigint`
- **数组类型**: 使用 `[]` 后缀，如 `string[]`、`(number | bigint)[]`
- **高阶函数**: 函数可以返回函数，如 `cwrap` 返回一个函数
- **剩余参数**: 使用 `...args` 表示可变参数

### C 指针在 TypeScript 中的表示

在 Emscripten/WASM 环境中，C 语言的指针使用 **`number`** 类型表示：

- **原因**: Emscripten 使用 32 位线性内存，指针是 32 位整数，JavaScript 的 `number` 类型可以安全表示
- **指针运算**: 指针可以进行数值运算（如 `ptr + 4` 表示偏移 4 字节）
- **NULL 检查**: 指针值为 0 表示 `NULL`，可以用 `if (!ptr)` 检查
- **内存访问**: 通过 `HEAPU8`、`getValue`、`setValue` 等方法访问指针指向的内存

示例：
```typescript
const dataPtr = this.module.ccall('decoder_malloc', 'number', ['number'], [size]);
const width = this.module.getValue(frameInfoPtr, 'i32');  // 读取指针指向的值
```

### Emscripten 运行时 API

以下接口都是 Emscripten 自带的运行时 API，需要在编译时通过 `EXPORTED_RUNTIME_METHODS` 导出：

- **`getValue(ptr, type)`**: 从 WASM 内存读取指定类型的值
- **`setValue(ptr, value, type)`**: 向 WASM 内存写入指定类型的值
- **`HEAPU8`**: `Uint8Array` 视图，用于按字节访问 WASM 线性内存
- **`HEAPF32`**: `Float32Array` 视图，用于按 32 位浮点数访问内存
- **`_malloc(size)`**: Emscripten 内置的内存分配函数（项目中未直接使用）
- **`_free(ptr)`**: Emscripten 内置的内存释放函数（项目中未直接使用）

注意：项目中实际使用的是自定义的 `decoder_malloc` 和 `decoder_free`（通过 `ccall` 调用），它们是对 FFmpeg `av_malloc`/`av_free` 的包装。

### WASM 内存

WASM 内存是 WebAssembly 模块使用的线性内存空间：

#### 核心概念

- **线性内存模型**: 一个连续的字节数组，从地址 0 开始，通过字节偏移（指针）访问
- **独立内存空间**: WASM 内存与 JavaScript 对象堆分离，需要显式传递数据
- **内存配置**: 
  - 初始内存：64MB (`INITIAL_MEMORY=67108864`)
  - 最大内存：512MB (`MAXIMUM_MEMORY=536870912`)
  - 允许动态增长 (`ALLOW_MEMORY_GROWTH=1`)

#### 内存访问方式

1. **通过 TypedArray 视图访问**:
   ```typescript
   // 写入数据
   this.module.HEAPU8.set(data, dataPtr);
   
   // 读取数据
   const yData = this.module.HEAPU8.subarray(yDataPtr, yDataPtr + ySize);
   ```

2. **通过 getValue/setValue 访问**:
   ```typescript
   // 读取结构化数据
   const width = this.module.getValue(frameInfoPtr, 'i32');
   const height = this.module.getValue(frameInfoPtr + 4, 'i32');
   ```

3. **直接数组索引访问**:
   ```typescript
   const char = this.module.HEAPU8[ptr + i];
   ```

#### 内存管理

- **手动管理**: 需要显式调用 `malloc` 分配和 `free` 释放内存
- **指针即地址**: 指针是内存地址（字节偏移），在 JavaScript 中用 `number` 表示
- **类型安全**: 通过 `getValue`/`setValue` 指定数据类型，或使用对应的 TypedArray 视图
- **性能优势**: 直接内存访问，无需序列化，适合大量数据传输

